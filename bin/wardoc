#! /bin/zsh

### wardoc â€” categorize and auto-document recent commits into markdown that's suitable as a pretty release page

start=$argv[1]
newtag=$argv[2]
range=$argv[3]

print -- start: $start -- newtag: $newtag -- range: $range >&2

feat=':new: Features'
bugs=':mechanic: Fixes (problems/brokenness)'
misc=':basket: Other/Misc (non-user facing)'
breaking=':bomb: Breaking Changes'
crises=':comet: Crises'

# Selected kinda from: gitmoji -l
declare -A emojis=(
     # GITMOJI (my version)
     ':sparkles:'    $feat # Features
     ':tada:'        $feat # begin project or major feature
     ':books:'       $feat # docs/comments (also memo)
     ':zap:'         $feat # Performance
     ':lock:'        $feat # Security/Privacy
     ':zap:'         $feat # perf (also racehorse/rabbit)
     ':wheelchair:'  $feat # accessibility
     ':lipstick:'    $feat # User Interface
     ':zap:'         $feat # Performance
     ':abc:'         $feat # i18n
     ':construction:' $feat # WIP, progress on incomplete feature

     ':bug:'         $bugs # Bug Fixes
     ':wastebasket:' $bugs # Removals

     ':wrench:'      $misc # Configuration
     ':recycle:'     $misc # Refactors
     ':rat:'         $misc # tests (also lab_coat/test_tube)
     ':flags:'       $misc # feature flag
     ':guard:'       $misc # compiler/linter/CI problem (temporary)
     ':ledger:'      $misc # logs (also satellite/mag)
     ':package:'     $misc # update deps (arrow_up)
     ':recycle:'     $misc # refactor/move things (also truck)
     ':poop:'        $misc # write bad code (OR remove code?)
     ':wrench:'      $misc # config (also hammer)
     ':bricks:'      $misc # infra
     ':key:'         $misc # secrets
     ':alien:'       $misc # 3rd-party API changes
     ':robot:'       $misc # automation
     ':alembic:'     $misc # experiments
     ':stethoscope:' $misc # health-check
     ':thread:'      $misc # concurrency

     ':boom:'        $breaking # Breaking Changes

     # MORE STANDARD
     'feat:'     $feat # Features
     'docs:'     $feat # Documentation
     'fix:'      $bugs  # Bug Fixes
     'refactor:' $misc # Refactors
     'build:'    $misc # Build Tooling
     'test:'     $misc # Testing
     'style:'    $misc # Styling
     'breaking change:' $breaking # Breaking Changes
)

# Could instead get this from parsing .git/config:remote.origin.url (url = git@github.com:MicahElliott/captain.git)
# repo=${GITHUB_REPOSITORY?var must be set to something like: octocat/Hello-World}
repo=$(git config remote.origin.url | sed -e 's/.*://' -e 's/.git$//')
ghurl='https://github.com/'
# repo="MicahElliott/captain"
url="$ghurl$repo"

# releaseurl="$url/releases/tag/$tag2"
releaseurl="$url/releases/tag/$newtag"
# print "# [${tag2}]($releaseurl)\n"
# This is wrong if range is date-based, but ignore
# print "**[Full Changelog]($url/compare/$range$newtag)**"
print "**[Full Changelog]($url/compare/$start...$newtag)**"

# Read into array
# logs=$(git log --pretty=format:"%s (%h)" $range)
# commits=()
# git log --pretty=format:"%s (%h)" $range >&2
commits=( "${(@f)$( git log --pretty=format:"%s (%h)" $=range )}" )
# print "git log --pretty=format:'(%h)' $range" >&2
# git log --pretty=format:"%s (%h)" $range | while read -r l; do lines+=$l; done
# git log --pretty=format:"%s (%h)" v2025.01.07...v2025.02.02 | while read -r l; do lines+=$l; done

# TODO summarize change with LLM
# ( print "Summarize the following git commits in a couple paragraphs" ; git log HEAD~19 ) | llm

print "\nCommits to be included:\n${(j:\n:)commits}" >&2

prefixes=( $(print -l $commits |cut -f1 -d' ' | sort -u) )
print prefixes: $prefixes >2

# Print each bucket with all of its commit types in it.
# Eg, feat bucket has sparkles and books together.
buckets=( "$feat" "$bugs" "$misc" "$breaking" "$crises" )
for bucket in $buckets
do   curs=()
     for c in $commits
     do   p=$(cut -f1 -d' ' <<< $c)
          if [[ $emojis[$p] == $bucket ]]
          then curs+=$c
          fi
     done
     if (( $#curs > 0 ))
     then print "\n## $bucket\n";
          for x in $curs; do print -- "- $x"; done
     fi
done

# Old way, making a new bucket for each prefix
# for p in $prefixes
# do if [[ -n $emojis[$p] ]]
#    then print "\n## $emojis[$p]\n"
#         logs=()
#         print -l $commits | grep $p | while read -r l; do logs+=$l; done
#         for l in $logs; do print -- "- $l"; done
#    fi
# done

print -- "\n_This release was created with [havoc](https://github.com/MicahElliott/havoc)._"
